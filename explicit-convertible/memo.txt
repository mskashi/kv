[2013/07/27]

今まで、is_convertible (とenable_if)を使って型のネストを実現していたが、
やはり自動型変換を残すのは不安定。
自分で書いた部分でないところで自動型変換に頼った書き方があると、
そこで思わぬambiguous errorが生じてしまうことがある。

安定にするには、double等から自作の型への自動型変換をさせないこと。
すなわち、引数一つのコンストラクタを全てexplicitにするのが良い。

しかし、explicitなコンストラクタがあるだけでは、is_convertibleはfalseに
なってしまう。そのため、今までは引数一つのコンストラクタにexplicitを
付けなかった。

よく考えると、明示的なキャストで変換可能な場合でもtrueを返すような
is_convertibleがあれば、引数一つのコンストラクタを全てexplicitにしても
よいのではないか。

そこで調べてみると、C++11にはis_constructibleがあり、これだと実現出来そう。
複数の引数を持つコンストラクタの存在も調べられる。
まだまだC++11を仮定するのは早い気がする。
そこで古いC++でも動くものを自作したくなるが、
is_constructibleはC++11の新しい機能を使っているらしく、自作は難しそう。

八方塞がりかと思えたが、

https://groups.google.com/forum/#!topic/comp.std.c++/tWdhe_zKvK0

の議論にあった、


On 15 Jun., 08:45, John Salmon <jsal...@thesalmons.org> wrote:
> Is there a type_trait that tells me whether a particular constructor
> exists.  For example, I'd like to know whether TO has a
> constructor from a specific type, FROM.  This is almost the
> same as is_convertible in boost and tr1, but is_convertible
> returns false if the constructor is explicit, and that's not
> what I want.
>> [...]

This one works for me with g++ 4.4 and comeau online compiler, and
looks like valid C++03.

#include <vector>
#include <string>

namespace detail {
template<int> struct D { };
typedef char yes[1];
typedef char no[2];

template<typename T, typename U>
yes &f(int, D<sizeof T(*(U*)0)>* = 0);

template<typename T, typename U>
no &f(...);
}

template<typename To, typename From>
struct IsExplicitlyConvertible {
 static bool const value = (sizeof detail::f<To, From>(0) ==
                            sizeof(detail::yes));
};

int main() {
 IsExplicitlyConvertible<std::vector<int>, int>::value; // true
 IsExplicitlyConvertible<float, int>::value; // true
 IsExplicitlyConvertible<std::string, int>::value; // false
}

For some weird reason, it fails to parse the f functions if they are
static member templates ("invalid use of type parameter 'T'").
Sometimes, it rises errors about not implemented expression manglings
(for the template signature). In this form, it seems to work for both
gcc and comeau.


--
[ comp.std.c++ is moderated.  To submit articles, try just posting with ]
[ your news-reader.  If that fails, use mailto:std...@netlab.cs.rpi.edu]
[              --- Please see the FAQ before posting. ---               ]
[ FAQ: http://www.comeaucomputing.com/csc/faq.html                      ]


のコードが使えそう。で、これを元に作ってみた。

